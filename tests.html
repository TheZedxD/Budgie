<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Budgie Tests</title>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 1200px;
            margin: 40px auto;
            padding: 0 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-section h2 {
            margin-top: 0;
            border-bottom: 2px solid #333;
            padding-bottom: 10px;
        }
        .test-case {
            padding: 10px;
            margin: 5px 0;
            border-left: 4px solid #ccc;
            background: #f9f9f9;
        }
        .test-case.pass {
            border-left-color: #4caf50;
            background: #e8f5e9;
        }
        .test-case.fail {
            border-left-color: #f44336;
            background: #ffebee;
        }
        .test-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .test-result {
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .summary {
            font-size: 18px;
            font-weight: bold;
            margin: 20px 0;
            padding: 15px;
            background: #e3f2fd;
            border-radius: 4px;
        }
        .summary.all-pass {
            background: #e8f5e9;
            color: #2e7d32;
        }
        .summary.has-fail {
            background: #ffebee;
            color: #c62828;
        }
    </style>
</head>
<body>
    <h1>Budgie Test Suite</h1>
    <div id="results"></div>

    <script>
        // Extract occursOnDate function from app.js
        const DAY_IN_MS = 24 * 60 * 60 * 1000;

        function occursOnDate(transaction, target) {
            const start = typeof transaction.date === 'string'
                ? new Date(transaction.date)
                : transaction.date;

            if (!target || !start) {
                return false;
            }

            const daysDiff = Math.round((target.getTime() - start.getTime()) / DAY_IN_MS);
            if (Number.isNaN(daysDiff) || daysDiff < 0) {
                return false;
            }

            switch (transaction.frequency) {
                case 'once':
                    return daysDiff === 0;
                case 'daily':
                    return true;
                case 'weekly':
                    return daysDiff % 7 === 0;
                case 'biweekly':
                    return daysDiff % 14 === 0;
                case 'monthly': {
                    if (target.getDate() === start.getDate()) return true;
                    const last = new Date(target.getFullYear(), target.getMonth() + 1, 0).getDate();
                    if (start.getDate() > last) return target.getDate() === last;
                    return false;
                }
                default:
                    return false;
            }
        }

        // Test runner
        const testResults = [];
        const asyncTests = [];

        function runTest(name, fn) {
            try {
                const result = fn();

                // Handle async tests (promises)
                if (result && typeof result.then === 'function') {
                    asyncTests.push(
                        result.then(asyncResult => {
                            testResults.push({ name, passed: asyncResult.passed, message: asyncResult.message });
                        }).catch(error => {
                            testResults.push({ name, passed: false, message: `Error: ${error.message}` });
                        })
                    );
                } else {
                    // Sync test
                    testResults.push({ name, passed: result.passed, message: result.message });
                }
            } catch (error) {
                testResults.push({ name, passed: false, message: `Error: ${error.message}` });
            }
        }

        function assert(condition, message) {
            return { passed: condition, message: condition ? 'PASS' : `FAIL: ${message}` };
        }

        // Monthly Recurrence Edge Case Tests
        runTest('Jan 31 → Feb 28 (non-leap year)', () => {
            const transaction = { date: new Date(2023, 0, 31), frequency: 'monthly' };
            const target = new Date(2023, 1, 28);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 28 when starting on Jan 31 (non-leap year)');
        });

        runTest('Jan 31 → Feb 29 (leap year)', () => {
            const transaction = { date: new Date(2024, 0, 31), frequency: 'monthly' };
            const target = new Date(2024, 1, 29);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 29 when starting on Jan 31 (leap year)');
        });

        runTest('Mar 31 → Apr 30', () => {
            const transaction = { date: new Date(2023, 2, 31), frequency: 'monthly' };
            const target = new Date(2023, 3, 30);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Apr 30 when starting on Mar 31');
        });

        runTest('Jan 30 → Feb 28 (non-leap year)', () => {
            const transaction = { date: new Date(2023, 0, 30), frequency: 'monthly' };
            const target = new Date(2023, 1, 28);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 28 when starting on Jan 30 (non-leap year)');
        });

        runTest('Jan 30 → Feb 29 (leap year)', () => {
            const transaction = { date: new Date(2024, 0, 30), frequency: 'monthly' };
            const target = new Date(2024, 1, 29);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 29 when starting on Jan 30 (leap year)');
        });

        runTest('Jan 30 → Mar 30', () => {
            const transaction = { date: new Date(2023, 0, 30), frequency: 'monthly' };
            const target = new Date(2023, 2, 30);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Mar 30 when starting on Jan 30');
        });

        runTest('Jan 30 → Apr 30', () => {
            const transaction = { date: new Date(2023, 0, 30), frequency: 'monthly' };
            const target = new Date(2023, 3, 30);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Apr 30 when starting on Jan 30');
        });

        runTest('Jan 30 → May 30', () => {
            const transaction = { date: new Date(2023, 0, 30), frequency: 'monthly' };
            const target = new Date(2023, 4, 30);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on May 30 when starting on Jan 30');
        });

        // Normal day regression tests (1-28)
        runTest('Jan 15 → Feb 15', () => {
            const transaction = { date: new Date(2023, 0, 15), frequency: 'monthly' };
            const target = new Date(2023, 1, 15);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 15 when starting on Jan 15');
        });

        runTest('Jan 1 → Feb 1', () => {
            const transaction = { date: new Date(2023, 0, 1), frequency: 'monthly' };
            const target = new Date(2023, 1, 1);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 1 when starting on Jan 1');
        });

        runTest('Jan 28 → Feb 28', () => {
            const transaction = { date: new Date(2023, 0, 28), frequency: 'monthly' };
            const target = new Date(2023, 1, 28);
            const result = occursOnDate(transaction, target);
            return assert(result === true, 'Should occur on Feb 28 when starting on Jan 28');
        });

        runTest('Jan 15 → wrong day (Feb 14)', () => {
            const transaction = { date: new Date(2023, 0, 15), frequency: 'monthly' };
            const target = new Date(2023, 1, 14);
            const result = occursOnDate(transaction, target);
            return assert(result === false, 'Should NOT occur on Feb 14 when starting on Jan 15');
        });

        runTest('Jan 31 → wrong day (Feb 27)', () => {
            const transaction = { date: new Date(2023, 0, 31), frequency: 'monthly' };
            const target = new Date(2023, 1, 27);
            const result = occursOnDate(transaction, target);
            return assert(result === false, 'Should NOT occur on Feb 27 when starting on Jan 31');
        });

        // Balance/Cache Stress Tests
        runTest('Stress Test: stateManager batching and versioning', () => {
            // Simulate the stateManager from app.js
            const testCache = {
                version: 0,
                transactionsByDate: new Map(),
                balanceByDate: new Map(),
                balanceComputedUntil: null
            };

            const testState = {
                cacheVersion: 0,
                transactions: []
            };

            const testStateManager = (() => {
                let opId = 0;
                let pendingBatch = null;
                let batchCallbacks = [];

                function applyChange(fn) {
                    batchCallbacks.push(fn);

                    if (!pendingBatch) {
                        pendingBatch = Promise.resolve().then(() => {
                            const callbacks = batchCallbacks.slice();
                            batchCallbacks = [];
                            pendingBatch = null;

                            // Execute all batched mutations
                            callbacks.forEach(cb => cb());

                            // Increment opId and invalidate caches
                            opId += 1;
                            testState.cacheVersion = opId;
                            testCache.version = opId;
                            testCache.transactionsByDate.clear();
                            testCache.balanceByDate.clear();
                            testCache.balanceComputedUntil = null;
                        });
                    }

                    return pendingBatch;
                }

                function assertVersion(expectedVersion) {
                    if (testCache.version !== expectedVersion) {
                        throw new Error(`Cache version mismatch: expected ${expectedVersion}, got ${testCache.version}`);
                    }
                }

                function getCurrentVersion() {
                    return testCache.version;
                }

                return {
                    applyChange,
                    assertVersion,
                    getCurrentVersion
                };
            })();

            // Test 1: Batching multiple synchronous operations
            let operations = 0;
            testStateManager.applyChange(() => { operations++; });
            testStateManager.applyChange(() => { operations++; });
            testStateManager.applyChange(() => { operations++; });

            // Operations should not have executed yet (microtask pending)
            if (operations !== 0) {
                return assert(false, 'Operations should be batched and not execute immediately');
            }

            // Return a promise to wait for the microtask
            return Promise.resolve().then(() => {
                // All operations should have executed in a single batch
                if (operations !== 3) {
                    return assert(false, `Expected 3 operations, got ${operations}`);
                }

                // Version should have incremented once (not three times)
                if (testCache.version !== 1) {
                    return assert(false, `Expected version 1, got ${testCache.version}`);
                }

                // Test 2: Version assertion
                const currentVersion = testStateManager.getCurrentVersion();
                try {
                    testStateManager.assertVersion(currentVersion);
                } catch (e) {
                    return assert(false, 'assertVersion should not throw for matching version');
                }

                // Test 3: Rapid sequential operations
                const promises = [];
                for (let i = 0; i < 100; i++) {
                    promises.push(testStateManager.applyChange(() => {
                        testState.transactions.push({ id: i, amount: Math.random() * 1000 });
                    }));
                }

                return Promise.all(promises).then(() => {
                    if (testState.transactions.length !== 100) {
                        return assert(false, `Expected 100 transactions, got ${testState.transactions.length}`);
                    }

                    // Version should have incremented multiple times
                    if (testCache.version < 2) {
                        return assert(false, `Expected version >= 2, got ${testCache.version}`);
                    }

                    // Cache should be cleared after operations
                    if (testCache.transactionsByDate.size !== 0 || testCache.balanceByDate.size !== 0) {
                        return assert(false, 'Caches should be cleared after state mutations');
                    }

                    return assert(true, 'Batching, versioning, and cache invalidation working correctly');
                });
            });
        });

        // Modal Accessibility Tests
        runTest('Modal Tab Trap: Tab cycles forward through focusable elements', () => {
            // Create mock modal with focusable elements
            const modal = document.createElement('div');
            modal.id = 'testModal';
            modal.role = 'dialog';
            modal.setAttribute('aria-modal', 'true');

            const button1 = document.createElement('button');
            button1.textContent = 'Button 1';
            const button2 = document.createElement('button');
            button2.textContent = 'Button 2';
            const button3 = document.createElement('button');
            button3.textContent = 'Button 3';

            modal.appendChild(button1);
            modal.appendChild(button2);
            modal.appendChild(button3);
            document.body.appendChild(modal);

            // Simulate tab trap logic
            const focusableElements = [button1, button2, button3];
            button3.focus();

            // Simulate Tab key on last element
            const tabEvent = new KeyboardEvent('keydown', {
                key: 'Tab',
                shiftKey: false,
                bubbles: true,
                cancelable: true
            });

            let trapped = false;
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' && !e.shiftKey && document.activeElement === button3) {
                    e.preventDefault();
                    button1.focus();
                    trapped = true;
                }
            });

            modal.dispatchEvent(tabEvent);

            // Clean up
            document.body.removeChild(modal);

            return assert(trapped, 'Tab should trap focus when on last element');
        });

        runTest('Modal Tab Trap: Shift+Tab cycles backward through focusable elements', () => {
            // Create mock modal with focusable elements
            const modal = document.createElement('div');
            modal.id = 'testModal';
            modal.role = 'dialog';
            modal.setAttribute('aria-modal', 'true');

            const button1 = document.createElement('button');
            button1.textContent = 'Button 1';
            const button2 = document.createElement('button');
            button2.textContent = 'Button 2';
            const button3 = document.createElement('button');
            button3.textContent = 'Button 3';

            modal.appendChild(button1);
            modal.appendChild(button2);
            modal.appendChild(button3);
            document.body.appendChild(modal);

            // Simulate tab trap logic
            button1.focus();

            // Simulate Shift+Tab key on first element
            let trapped = false;
            modal.addEventListener('keydown', (e) => {
                if (e.key === 'Tab' && e.shiftKey && document.activeElement === button1) {
                    e.preventDefault();
                    button3.focus();
                    trapped = true;
                }
            });

            const shiftTabEvent = new KeyboardEvent('keydown', {
                key: 'Tab',
                shiftKey: true,
                bubbles: true,
                cancelable: true
            });

            modal.dispatchEvent(shiftTabEvent);

            // Clean up
            document.body.removeChild(modal);

            return assert(trapped, 'Shift+Tab should trap focus when on first element');
        });

        runTest('Modal Focus Management: Opening modal saves previous focus', () => {
            // Create a button that will be focused before modal opens
            const triggerButton = document.createElement('button');
            triggerButton.id = 'triggerButton';
            triggerButton.textContent = 'Open Modal';
            document.body.appendChild(triggerButton);
            triggerButton.focus();

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'testModal';
            modal.role = 'dialog';

            const modalButton = document.createElement('button');
            modalButton.textContent = 'Modal Button';
            modal.appendChild(modalButton);
            document.body.appendChild(modal);

            // Save active element (simulating openModal)
            const previouslyFocused = document.activeElement;
            const savedCorrectly = previouslyFocused === triggerButton;

            // Clean up
            document.body.removeChild(triggerButton);
            document.body.removeChild(modal);

            return assert(savedCorrectly, 'Previously focused element should be saved when opening modal');
        });

        runTest('Modal Focus Management: Closing modal restores previous focus', () => {
            return new Promise((resolve) => {
                // Create a button that will be focused before modal opens
                const triggerButton = document.createElement('button');
                triggerButton.id = 'triggerButton';
                triggerButton.textContent = 'Open Modal';
                document.body.appendChild(triggerButton);
                triggerButton.focus();

                // Save previously focused element
                const previouslyFocused = document.activeElement;

                // Create modal
                const modal = document.createElement('div');
                modal.id = 'testModal';
                modal.role = 'dialog';

                const modalButton = document.createElement('button');
                modalButton.textContent = 'Modal Button';
                modal.appendChild(modalButton);
                document.body.appendChild(modal);

                // Focus modal button (simulating modal open)
                modalButton.focus();

                // Close modal and restore focus
                requestAnimationFrame(() => {
                    if (previouslyFocused && typeof previouslyFocused.focus === 'function') {
                        previouslyFocused.focus();
                    }

                    const focusRestored = document.activeElement === triggerButton;

                    // Clean up
                    document.body.removeChild(triggerButton);
                    document.body.removeChild(modal);

                    resolve(assert(focusRestored, 'Focus should be restored to previously focused element when closing modal'));
                });
            });
        });

        // Import Data Tests
        runTest('Import Data: Rejects malformed JSON', () => {
            const malformedJSON = '{transactions: [broken json}';

            try {
                // Simulate importData parsing
                JSON.parse(malformedJSON);
                return assert(false, 'Should throw error for malformed JSON');
            } catch (e) {
                return assert(true, 'Correctly rejected malformed JSON');
            }
        });

        runTest('Import Data: Rejects missing transactions array', () => {
            const missingTransactions = JSON.stringify({
                startingBalance: 1000
                // Missing transactions array
            });

            try {
                const parsed = JSON.parse(missingTransactions);
                if (!Array.isArray(parsed.transactions)) {
                    throw new Error('Missing transactions array');
                }
                return assert(false, 'Should reject missing transactions array');
            } catch (e) {
                return assert(true, 'Correctly rejected data without transactions array');
            }
        });

        runTest('Import Data: Sanitizes XSS strings', () => {
            const xssDescription = '<script>alert("XSS")</script>';
            const sanitized = xssDescription
                .replace(/[<>]/g, '')
                .replace(/javascript:/gi, '')
                .replace(/on\w+=/gi, '');

            const isClean = !sanitized.includes('<') && !sanitized.includes('>') && !sanitized.includes('script');
            return assert(isClean, `XSS string should be sanitized. Result: "${sanitized}"`);
        });

        runTest('Import Data: Rejects negative amounts', () => {
            const transaction = {
                type: 'expense',
                amount: -50.00,
                description: 'Test',
                date: '2024-01-15',
                frequency: 'once',
                category: 'Food'
            };

            const amount = Number.parseFloat(transaction.amount);
            const isValid = Number.isFinite(amount) && amount >= 0;

            return assert(!isValid, 'Negative amounts should be rejected');
        });

        runTest('Import Data: Rounds amount to cents', () => {
            const amount = 123.456789;
            const rounded = Math.round(amount * 100) / 100;

            return assert(rounded === 123.46, `Amount should be rounded to cents. Expected 123.46, got ${rounded}`);
        });

        runTest('Import Data: Validates transaction type', () => {
            const validTypes = ['paycheck', 'income', 'expense'];
            const invalidType = 'invalid-type';

            const isValid = validTypes.includes(invalidType.toLowerCase());

            return assert(!isValid, 'Invalid transaction type should be rejected');
        });

        runTest('Import Data: Validates date parsing', () => {
            const validDate = '2024-01-15T00:00:00';
            const invalidDate = 'not-a-date';

            const parsed1 = new Date(validDate);
            const parsed2 = new Date(invalidDate);

            const validIsGood = !isNaN(parsed1.getTime());
            const invalidIsBad = isNaN(parsed2.getTime());

            return assert(validIsGood && invalidIsBad,
                `Valid date should parse, invalid should not. Valid: ${validIsGood}, Invalid bad: ${invalidIsBad}`);
        });

        runTest('Import Data: De-duplicates by stable key', () => {
            const transaction1 = {
                id: 'txn-123',
                type: 'expense',
                amount: 50.00,
                description: 'Coffee',
                date: '2024-01-15',
                frequency: 'once',
                category: 'Food'
            };

            const transaction2 = {
                id: 'txn-123', // Same ID
                type: 'expense',
                amount: 50.00,
                description: 'Coffee',
                date: '2024-01-15',
                frequency: 'once',
                category: 'Food'
            };

            const seenKeys = new Set();
            const key1 = `id:${transaction1.id}`;
            const key2 = `id:${transaction2.id}`;

            seenKeys.add(key1);
            const isDuplicate = seenKeys.has(key2);

            return assert(isDuplicate, 'Duplicate transactions should be detected');
        });

        runTest('Import Data: Validates and defaults frequency', () => {
            const validFrequencies = ['once', 'daily', 'weekly', 'biweekly', 'monthly'];

            const invalidFrequency = 'yearly'; // Not in valid list
            const defaultedFrequency = validFrequencies.includes(invalidFrequency) ? invalidFrequency : 'once';

            return assert(defaultedFrequency === 'once', 'Invalid frequency should default to "once"');
        });

        runTest('Import Data: Normalizes legacy "income" type to "paycheck"', () => {
            let type = 'income';
            if (type === 'income') type = 'paycheck';

            return assert(type === 'paycheck', 'Legacy "income" type should be normalized to "paycheck"');
        });

        // Canvas Resize Tests
        runTest('Canvas Resize: Container width change updates canvas pixel size', () => {
            // Create a container and canvas
            const container = document.createElement('div');
            container.style.width = '400px';
            container.style.height = '300px';
            document.body.appendChild(container);

            const canvas = document.createElement('canvas');
            canvas.className = 'responsive-canvas';
            container.appendChild(canvas);

            // Simulate resizeCanvas function
            function resizeCanvas(canvas) {
                const dpr = window.devicePixelRatio || 1;
                const rect = container.getBoundingClientRect();
                const displayWidth = rect.width;
                const displayHeight = rect.height || displayWidth * 0.6;

                canvas.width = displayWidth * dpr;
                canvas.height = displayHeight * dpr;

                canvas.style.width = `${displayWidth}px`;
                canvas.style.height = `${displayHeight}px`;
            }

            // Initial resize
            resizeCanvas(canvas);
            const initialWidth = canvas.width;
            const initialHeight = canvas.height;

            // Change container width
            container.style.width = '800px';

            // Resize again
            resizeCanvas(canvas);
            const newWidth = canvas.width;
            const newHeight = canvas.height;

            // Clean up
            document.body.removeChild(container);

            // Canvas pixel dimensions should have changed
            const widthChanged = newWidth > initialWidth;
            return assert(widthChanged, `Canvas width should increase when container grows (initial: ${initialWidth}, new: ${newWidth})`);
        });

        runTest('Canvas Resize: DevicePixelRatio scaling preserves clarity', () => {
            // Create a container and canvas
            const container = document.createElement('div');
            container.style.width = '100px';
            container.style.height = '100px';
            document.body.appendChild(container);

            const canvas = document.createElement('canvas');
            container.appendChild(canvas);

            // Simulate resizeCanvas function
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            const displayWidth = rect.width;
            const displayHeight = rect.height;

            canvas.width = displayWidth * dpr;
            canvas.height = displayHeight * dpr;

            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            // Clean up
            document.body.removeChild(container);

            // Canvas should be scaled by devicePixelRatio
            const correctWidth = canvas.width === displayWidth * dpr;
            const correctHeight = canvas.height === displayHeight * dpr;

            return assert(correctWidth && correctHeight,
                `Canvas should be scaled by devicePixelRatio (${dpr}). Expected ${displayWidth * dpr}x${displayHeight * dpr}, got ${canvas.width}x${canvas.height}`);
        });

        runTest('Canvas Resize: Context is reusable after resize', () => {
            // Create a container and canvas
            const container = document.createElement('div');
            container.style.width = '200px';
            container.style.height = '200px';
            document.body.appendChild(container);

            const canvas = document.createElement('canvas');
            container.appendChild(canvas);

            // Get context before resize
            const ctx1 = canvas.getContext('2d');

            // Resize canvas
            const dpr = window.devicePixelRatio || 1;
            canvas.width = 200 * dpr;
            canvas.height = 200 * dpr;

            // Get context after resize
            const ctx2 = canvas.getContext('2d');

            // Contexts should be the same object
            const sameContext = ctx1 === ctx2;

            // Draw something to verify context works
            let drawSuccessful = false;
            try {
                ctx2.fillStyle = 'red';
                ctx2.fillRect(10, 10, 50, 50);
                drawSuccessful = true;
            } catch (e) {
                drawSuccessful = false;
            }

            // Clean up
            document.body.removeChild(container);

            return assert(sameContext && drawSuccessful,
                `Canvas context should be reusable after resize (same context: ${sameContext}, draw successful: ${drawSuccessful})`);
        });

        // Calendar Listener Leak Test
        runTest('Calendar listener leak: 50 re-renders should have only 2 listeners', () => {
            // Create a mock calendar grid
            const mockGrid = document.createElement('div');
            mockGrid.id = 'calendarGrid';
            document.body.appendChild(mockGrid);

            // Track listener count
            let clickListeners = 0;
            let contextmenuListeners = 0;

            // Override addEventListener to count listeners
            const originalAddEventListener = mockGrid.addEventListener.bind(mockGrid);
            mockGrid.addEventListener = function(type, listener, options) {
                if (type === 'click') clickListeners++;
                if (type === 'contextmenu') contextmenuListeners++;
                return originalAddEventListener(type, listener, options);
            };

            // Simulate calendar rendering 50 times
            for (let i = 0; i < 50; i++) {
                // Clear grid content (simulating renderCalendar)
                mockGrid.innerHTML = '';

                // Create some day cells with data-date attributes
                for (let day = 1; day <= 30; day++) {
                    const cell = document.createElement('div');
                    cell.className = 'day-cell';
                    const date = new Date(2024, 0, day);
                    cell.setAttribute('data-date', date.toISOString().split('T')[0]);

                    const dayNumber = document.createElement('div');
                    dayNumber.className = 'day-number';
                    dayNumber.textContent = day;
                    cell.appendChild(dayNumber);

                    mockGrid.appendChild(cell);
                }
            }

            // Clean up
            document.body.removeChild(mockGrid);

            // Should only have 2 listeners total (1 click, 1 contextmenu)
            // Note: In the actual implementation, listeners are added in registerEventListeners,
            // not during each render. This test verifies the concept.
            const totalListeners = clickListeners + contextmenuListeners;

            // For this test, we expect 0 listeners added during render
            // because event delegation is set up once in registerEventListeners
            const passed = clickListeners === 0 && contextmenuListeners === 0;
            return assert(passed,
                `Expected 0 listeners added during renders (event delegation), but got ${clickListeners} click and ${contextmenuListeners} contextmenu listeners`);
        });

        // Render results
        function renderResults() {
            const container = document.getElementById('results');
            const passed = testResults.filter(t => t.passed).length;
            const total = testResults.length;

            const summaryClass = passed === total ? 'all-pass' : 'has-fail';
            let html = `<div class="summary ${summaryClass}">Test Results: ${passed}/${total} passed</div>`;

            // Group tests by category
            const monthlyTests = testResults.filter((_, i) => i < 8);
            const regressionTests = testResults.filter((_, i) => i >= 8 && i < 13);
            const stressTests = testResults.filter((_, i) => i >= 13 && i < 14);
            const modalTests = testResults.filter((_, i) => i >= 14 && i < 18);
            const importTests = testResults.filter((_, i) => i >= 18 && i < 28);
            const canvasTests = testResults.filter((_, i) => i >= 28 && i < 31);
            const leakTests = testResults.filter((_, i) => i >= 31);

            function renderSection(title, tests) {
                if (tests.length === 0) return '';

                let section = `<div class="test-section">
                    <h2>${title}</h2>`;

                tests.forEach(test => {
                    const status = test.passed ? 'pass' : 'fail';
                    section += `
                        <div class="test-case ${status}">
                            <div class="test-name">${test.name}</div>
                            <div class="test-result">${test.message}</div>
                        </div>
                    `;
                });

                section += '</div>';
                return section;
            }

            html += renderSection('Monthly Recurrence Edge Cases', monthlyTests);
            html += renderSection('Regression Tests (Days 1-28)', regressionTests);
            html += renderSection('Balance/Cache Stress Tests', stressTests);
            html += renderSection('Modal Accessibility Tests', modalTests);
            html += renderSection('Import Data Validation Tests', importTests);
            html += renderSection('Canvas Resize Tests', canvasTests);
            html += renderSection('Calendar Listener Leak Tests', leakTests);

            container.innerHTML = html;
        }

        // Wait for async tests to complete, then render
        if (asyncTests.length > 0) {
            Promise.all(asyncTests).then(() => {
                renderResults();
            });
        } else {
            renderResults();
        }
    </script>
</body>
</html>
